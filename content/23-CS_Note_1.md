+ 计算机三个根本性基础:输入，运算，输出

<hr>

+ 软件=指令+数据

<hr>

+ 对于计算机来说，一切都是数字

<hr>

+ 微型计算机基础必备硬件:cpu,io,内存

<hr>

+ 作为计算机大脑的cpu只能解释执行一种语言：二进制数构成的机器语言

<hr>

+ 由二进制数构成的程序,CPU可直接对其解释执行

<hr>

+ 标识内存或I/O中存储单元的数字,称为"地址"

<hr>

+ 一旦执行了算术运算,逻辑运算,比较运算等指令后,标志(FLAG)寄存器并不会存放运算结果值,而是把运算后的某种状态存储起来,例如运算结果是否为0,是否产生了负数,是否有溢出(over flow)等等

<hr>

+ CPU中存储数据之地称为寄存器,其与I/O寄存器不同,CPU寄存器不仅可以存储数据,亦可对数据进行运算

<hr>

+ 计算机硬件:CPU+I/O+内存

<hr>

+ 内存中存储着程序(即指令+数据),CPU配合着由时钟发出的滴答滴答的时钟信号,从内存中发出指令,然后再依次对其解释执行

<hr>

+ CPU中含有各式各样的各司其职的寄存器,其中一种名为PC(program conter)寄存器,负责存储内存的地址,该地址指向下一条将要执行的指令.每解释执行完一条指令,PC寄存器的值会自动被更新为下一条指令的地址.

<hr>

+ 一个编号的地址可以存储一个字节的指令

<hr>

+ 算法定义:被明确定义的有限个规则的集合,用于根据有限的步骤解决问题.例如在既定精度下,把求解sin x的计算步骤无一遗漏地记录下来的文字.

<hr>

+ 算法定义(2):把解决问题的步骤,无一遗漏地用文字或图形表示出来.步骤必须是明确的,步骤数必须是有限的

<hr>

+ 变量中存储的数据是可以改变的,变量的实质是按变量所存储数据的大小,被分配到的一块内存空间

<hr>

+ 数组的实质是连续分配的一块特定大小的内存空间

<hr>

+ 数据结构之基础:数组.因为数组反映了内存的物理结构之本身,在内存中存储数据的空间是连续分布的

<hr>

+ 函数在程序编译时被分配了一个入口地址,此函数入口地址即称为函数指针


<hr>


# Data Structure Invoke Links


## 汇编的角度分析指针 
<a>https://www.cnblogs.com/heyhx/p/14227363.html</a>  



## 启舰  
https://www.zhihu.com/question/303208441


## 经验参考
https://www.zhihu.com/question/399753856

<br>

https://www.zhihu.com/question/419946633

<br>

https://www.cxyxiaowu.com/7072.html

## 练习集
https://pintia.cn/problem-sets?tab=0

## AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中
https://www.zhihu.com/question/30527705



<hr>


## C-数组与指针

```

int main(){
	//数组名是一个指向数组中第一个元素的常量指针
	int array[4]={1,22,333,4444};
	
	int *pt;

	/*array 是一个指向 &array[0] 的指针,
    即数组 array 的第一个元素的地址.下面是把 pt 赋值为 array 的第一个元素的地址*/
	pt=array;

	/*
	使用数组名作为常量指针是合法的，反之亦然。因此，*(pt + 4) 是一种访问 array[4] 数据的合法方式
	 */
	for(int i=0;i<4;i++){
		printf("第%d个值:%d \t",i+1,*(pt+i));
	}

	return 0;
}

```


<hr>

## C: typedef struct


值得注意的是,在创建链表时:

``````

typedef struct NODE{
    int data;
    struct NODE* next;
}ptr;

``````  

创建指针使用的是 **struct NODE* next**  

在之后的创建、插入、删除、查找函数，以及主函数中，
声明指针统一用的是 **ptr* a**



<hr>


## 学习计组之前有必要学习汇编语言吗？


https://www.zhihu.com/question/371500292


没有必要。汇编语言与计算机组成是两个层次的不同东西。你以为ARM汇编只能在ARM架构的机器上跑？  
并不是，很容易就可以写出一个模拟器（虚拟机），然后跑在任意的平台上。  
因此，学习汇编语言并不能让你更好地理解计算机组成。学习汇编，可以让你对一个机器编程，让你对机器的运行原理有端到端的观察，但这种观察是极其有限的。  
反而，学习计算机组成，对深化理解汇编是有帮助的。因为它给出了汇编语言背后的运行机制。懂计算机组成的人写出来的汇编和不懂的人写出来的汇编，运行效率天差地别。  
升华一下，汇编的抽象层次高，计算机组成的抽象层次低。低层次实例可以作为高层次概念的具体例子，从而印证自己对高层次概念的理解，进而帮助学习高层次概念。而学习高层次概念并不能直观举出一个低层次实例，这个过程需要设计与实现，往往需要天才般的构造。


<hr>


## Data Structure Learning Note

+ 求循环队列中的元素个数公式
	`(Q.rear-Q.front+MaxSize)%MaxSize`
    
+ **用指针变量作函数参数可以将函数外部的地址传递到函数内部，
使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁**

-----------------------


+ 图
  - 顶点a的入度：以a为终点的有向边的条数，记作ID(a),即进来的边数
  - 顶点a的出度：以a为起始点的有向边的条数，记作OD(a),即发出的边数
  - 顶点a的度等于其出度与入度之和: TD(a)=ID(a)+OD(a)
  
    
      
      
--------------------------  
      
+ 两个顶点之间连接着一条线,有方向箭头的称之为弧,无方向箭头则称之为边.  

+ 哈夫曼编码的核心思想是：权值越大的结点，离根越近

+ 哈夫曼树：使用频率越高的数据结点，被安排离根结点越近，在构建哈夫曼树的时候,会被要求在输入数据的同时，也要输入此数据的使用频繁度，这个频繁度也叫做权数


